--practica 4

Estructuras Discretas 2023-1
Profesora: Dra. Lourdes del Carmen González Huesca

Integrantes del equipo:
Jacome Delgado Alejandro
Jimenez Sanchez Emma Alicia

Esta mejor explicado en el código

{-# LANGUAGE InstanceSigs #-}


data LProp = PTrue | PFalse | Var Nombre | Neg LProp |Conj LProp LProp | Disy LProp LProp | Impl LProp LProp |Syss LProp LProp
type Nombre = String -- Nombre es un sinonimo para String.
type Asignacion = [(Nombre, Int)]

En esta clase de instancia se indica como se debe de mostrar los resultados de los datos.

--show Crea la instancia de la clase show para LProp utilizando los símbolos adecuados.
instance Show LProp where
    show :: LProp -> String
    show(Var a)=show a
    show PTrue=show True
    show PFalse=show False
    show (Neg a)= "¬"++ show a
    show (Conj a b)= "("++ show a ++" ^ "++show b++")"
    show (Disy a b)=  "("++show a ++" v "++show b++")"
    show (Impl a b)=  "("++show a ++" -> "++show b++")"
    show (Syss a b)=  "("++show a ++" <-> "++show b++")"

--vars 
--Función que recibe una LProp y regresa la lista con todas las variables que aparecen en la expresión.
--La firma es de va de una proposición lógica a una lista de string.
vars :: LProp -> [String]
vars PTrue  = []
vars PFalse  = []
vars (Var a) = [a] //Si solamente tiene una variable devuelve esa variable
vars (Neg a) = vars a //Devuelve solamente una variable porque el conector es unitario.
//Con ayuda de una función auxiliar se busca si no estan repetidas las variables, y se van concatenando.
vars (Conj a b) = aux1 (vars a ++ vars b)
vars (Impl a b) = aux1 (vars a ++ vars b)
vars (Syss a b) = aux1 (vars a ++ vars b)
-- Función que filtra los elementos repetidos de las listas
aux1 :: (Eq a) => [a] -> [a] 
aux1 [] = []
aux1 (x:xs) = x : aux1 (filter (/= x) xs)


--asocia_der 
--Función que recibe una LProp y aplica la ley de la asociatividad hacia la derecha sobre los elementos de la expresión.
En la firma entra una proposición lógica y nos regresa una proposición lógica, la firma es igual en todas las funciones en esta práctica, excepto por la interpretación, vars y num_conectores.
La asociación a la derecha solamente se debe de hacer en proposiciones lógicas donde haya disyunción y conjunción, así que la recursividad se aplica en los demás conectores que tenemos. Esto aplica lo mismo en la asocia_izq, ya que se utiliza el mismo algoritmo.
asocia_der :: LProp -> LProp
asocia_der PFalse=PFalse
asocia_der PTrue=PTrue
asocia_der (Conj (Conj (a) (b)) (c)) = (Conj (a)(Conj (b) (c)))
asocia_der (Conj (a) (Conj (b) (c))) = (Conj (a)(Conj (b) (c)))
asocia_der (Disy (Disy (a) (b)) (c)) = (Disy (a)(Disy (b) (c)))
asocia_der (Disy (a) (Disy (b) (c))) = (Disy (a)(Disy (b) (c)))
asocia_der (Neg a)=Neg(asocia_der a)
asocia_der (Impl a b)= Impl(asocia_der a)(asocia_der b)
asocia_der (Syss a b) = Syss(asocia_der a)(asocia_der b)

--asocia_izq 
--Lo mismo que asocia_der pero para el otro lado.
asocia_izq :: LProp -> LProp
asocia_izq PFalse=PFalse
asocia_izq PTrue=PTrue
asocia_izq (Syss PTrue PTrue) = (Syss PTrue PTrue)
asocia_izq (Conj (Conj (a) (b)) (c)) = (Conj (Conj (a) (b)) (c))
asocia_izq (Conj (a) (Conj (b) (c))) = (Conj (Conj (a) (b)) (c))
asocia_izq (Disy (Disy (p) (q)) (r)) = (Disy (Disy (p) (q)) (r))
asocia_izq (Disy (p) (Disy (q) (r))) = (Disy (Disy (p) (q)) (r))
asocia_izq (Neg a)=Neg (asocia_izq a)
asocia_izq(Impl a b)= Impl (asocia_izq a)(asocia_izq b)
asocia_izq (Syss a b) = Syss(asocia_izq a)(asocia_izq b)

--conm 
--Función que recibe una LPropr y aplica la ley de la conmutatividad de forma exhaustiva sobre los elementos de la expresión 
--cuyo operador lógico sea conjunción o disyunción.
Como solamente se aplica en los operadores de conjunción o disyunción estos serán nuestros casos bases y la recursividad de aplica en los demás operadores.
conm :: LProp -> LProp
conm (Conj (a)(b))=(Conj(b)(a))
conm (Disy (b)(a))=(Disy(a)(b))
conm PFalse=PFalse
conm PTrue=PTrue
conm (Neg a)=Neg(conm a)
conm (Impl a b)=Impl(conm a)(conm b)
conm (Syss a b)=Syss(conm a)(conm b)

--dist 
--Función que recibe una LProp y aplica la ley de distributividad de forma exhaustiva sobre toda la expresión.
En esta función la firma nos indica que debemos introducir una proposición lógica y regresar otra.
En esta función se aplica la distributividad, donde si solamente se ingresa una variable nos regresa esa variable, ya cuando tenemos la distributividad en junto con una conjunción o disyunción, uno de los símbolos se queda afuera y el otro aplica para las variables que se tiene, después nada más en los demás indicamos la recursividad.
dist :: LProp -> LProp
dist PFalse = PFalse
dist PTrue = PTrue
dist (Var a) = (Var a)
dist (Neg a)= Neg(dist a)
dist (Conj (a) (Disy (b) (c))) = (Disy (Conj (dist(a)) (dist(b))) (Conj (dist(a)) (dist (c))))
dist (Disy (a) (Conj (b) (c))) = (Conj (Disy (dist(a)) (dist(b))) (Disy (dist(a)) (dist (c))))
dist (Conj a b)= Conj(dist a)(dist b)
dist (Disy a b)= Disy(dist a)(dist b)  
dist (Impl a b)= Impl(dist a)(dist b)
dist (Syss a b)= Syss(dist a)(dist b)

--deMorgan 
--Función que le aplica a una LProp las leyes de De morgan.
En la firma de la funcipon deMorgan se tiene que se ingresa una proposicón lógica y nos devuelve otra proposición lógica.
Aquí nada más se aplica cuando tenemos negado a la disyunción y conjunción, así que estos serán nuestros casos bases a aplicar, ya que en la implicación, negación y la doble implicación no se utiliza la deMorgan, estos serán nuestros casos recursivos.
deMorgan :: LProp -> LProp
deMorgan (Neg (Conj (a) (b))) = (Disy (Neg(a)) (Neg(b)))
deMorgan (Neg (Disy (a) (b))) = (Conj (Neg(a)) (Neg(b)))
deMorgan (Impl (a)(b))= Impl (a)(b)
deMorgan (Syss (a)(b))= Syss (a)(b)
deMorgan (Neg (Neg (o))) = (Neg (Neg (o)))
deMorgan (Neg (a)) = (Neg (deMorgan a))
deMorgan (Conj (a)(b))= Conj (deMorgan a)(deMorgan b)
deMorgan (Disy (a)(b))= Disy (deMorgan a)(deMorgan b)
deMorgan (Impl (a)(b))= Impl (deMorgan a)(deMorgan b)
deMorgan (Syss (a)(b))= Syss (deMorgan a)(deMorgan b)

--equiv_op 
--Función que recibe una LProp y aplica la equivalencia de operadores que se describe al inicio de este documento.


--dobleNeg 
--Función que quita las dobles negaciones de una LProp.
En esta función se ingresa una proposición lógica y nos regresa una proposición lógica.
Cuando se tiene que tenemos negado doblenegado una proposición o una variable nos debe de devolver lo mismo, pero sin las negaciones si solamente tiene una se hace una recursión para ver si no hay más negaciones y solamente se quedaría con esa. Fianlmente esto se aplica en los demás conectores en forma recursiva.
dobleNeg :: LProp -> LProp
dobleNeg PFalse = PFalse
dobleNeg PTrue = PTrue
dobleNeg (Var a) = Var a
dobleNeg (Neg (Neg a)) = dobleNeg a
dobleNeg (Neg a) = Neg (dobleNeg a)
dobleNeg (Conj a b) = Conj (dobleNeg a) (dobleNeg b)
dobleNeg (Disy a b) = Disy (dobleNeg a) (dobleNeg b)
dobleNeg (Syss a b) = Syss (dobleNeg a) (dobleNeg b)
dobleNeg (Impl a b) = Impl (dobleNeg a) (dobleNeg b)
